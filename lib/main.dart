import 'package:flutter/material.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:share_plus/share_plus.dart';
import 'package:flutter/services.dart'; // For clipboard
import 'package:hole/src/rust/api.dart'; // Generated by FRB
import 'package:hole/src/rust/frb_generated.dart'; // Generated by FRB

void main() async {
  await RustLib.init();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Hole',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Hole'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.upload), text: 'Send'),
            Tab(icon: Icon(Icons.download), text: 'Receive'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: const [
          SendPage(),
          ReceivePage(),
        ],
      ),
    );
  }
}

class SendPage extends StatefulWidget {
  const SendPage({super.key});

  @override
  State<SendPage> createState() => _SendPageState();
}

class _SendPageState extends State<SendPage> {
  String? _selectedPath;
  List<String> _logs = [];
  String? _ticket;
  bool _isSharing = false;

  Future<void> _pickAndShare() async {
    if (_isSharing) return;

    // file_picker usually doesn't need pre-requested permissions on Android
    // as it uses intents. Manual check can cause "Mismatch between current collecting".
    
    FilePickerResult? result = await FilePicker.platform.pickFiles();
    if (result != null && result.files.single.path != null) {
      setState(() {
        _selectedPath = result.files.single.path;
        _logs = ["Selected: $_selectedPath"];
        _ticket = null;
        _isSharing = true;
      });

      final appDir = await getApplicationDocumentsDirectory();
      
      try {
        final stream = startSend(
          filePath: _selectedPath!, 
          dataDir: appDir.path
        );
        
        await for (final msg in stream) {
          if (msg.startsWith("TICKET:")) {
            setState(() {
              _ticket = msg.substring(7);
            });
          }
          setState(() {
            _logs.add(msg);
          });
        }
      } catch (e) {
        setState(() {
          _logs.add("Error: $e");
          _isSharing = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          ElevatedButton.icon(
            onPressed: _isSharing ? null : _pickAndShare,
            icon: const Icon(Icons.file_open),
            label: const Text('Pick File & Share'),
          ),
          const SizedBox(height: 20),
          if (_ticket != null) ...[
            const Text("Share this Ticket:", style: TextStyle(fontWeight: FontWeight.bold)),
            SelectableText(
              _ticket!,
              style: const TextStyle(fontFamily: 'monospace', backgroundColor: Colors.black12),
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: const Icon(Icons.copy),
                  tooltip: 'Copy Ticket',
                  onPressed: () {
                    Clipboard.setData(ClipboardData(text: _ticket!));
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Ticket copied!')),
                    );
                  },
                ),
                IconButton(
                  icon: const Icon(Icons.qr_code),
                  tooltip: 'Show QR Code',
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (context) => AlertDialog(
                        title: const Text('Ticket QR Code'),
                        content: SizedBox(
                          width: 250,
                          height: 250,
                          child: Center(
                            child: QrImageView(
                              data: _ticket!,
                              version: QrVersions.auto,
                              size: 200.0,
                            ),
                          ),
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: const Text('Close'),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ],
            ),
          ],
          const Divider(),
          Expanded(
            child: ListView.builder(
              itemCount: _logs.length,
              itemBuilder: (ctx, i) => Text(_logs[i], style: const TextStyle(fontSize: 12)),
            ),
          ),
        ],
      ),
    );
  }
}

class ReceivePage extends StatefulWidget {
  const ReceivePage({super.key});

  @override
  State<ReceivePage> createState() => _ReceivePageState();
}

class ReceivedFile {
  final String name;
  final String path;
  final DateTime time;

  ReceivedFile({required this.name, required this.path, required this.time});
}

class _ReceivePageState extends State<ReceivePage> {
  final _controller = TextEditingController();
  List<String> _logs = [];
  List<ReceivedFile> _receivedFiles = [];
  bool _isDownloading = false;

  Future<void> _startDownload() async {
    final ticket = _controller.text.trim();
    if (ticket.isEmpty || _isDownloading) return;

    setState(() {
      _isDownloading = true;
      _logs = ["Starting download..."];
    });

    try {
      final appDir = await getApplicationDocumentsDirectory();
      final downloadDir = Directory('${appDir.path}/downloads');
      if (!await downloadDir.exists()) {
        await downloadDir.create(recursive: true);
      }
      
      final stream = receiveFile(
        ticketStr: ticket,
        dataDir: appDir.path,
        downloadDir: downloadDir.path
      );

      String? lastSavedPath;
      await for (final msg in stream) {
        setState(() {
          _logs.add(msg);
        });
        if (msg.startsWith("Path: ")) {
          lastSavedPath = msg.substring(6);
        }
      }

      if (lastSavedPath != null) {
        final file = File(lastSavedPath);
        setState(() {
          _receivedFiles.insert(0, ReceivedFile(
            name: file.path.split('/').last,
            path: file.path,
            time: DateTime.now(),
          ));
        });
      }
    } catch (e) {
      setState(() {
        _logs.add("Error: $e");
      });
    } finally {
      setState(() {
        _isDownloading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _controller,
                  decoration: const InputDecoration(
                    labelText: 'Paste Ticket Here',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                icon: const Icon(Icons.qr_code_scanner),
                onPressed: _scanQRCode,
                tooltip: 'Scan QR Code',
              ),
            ],
          ),
          const SizedBox(height: 10),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: _isDownloading ? null : _startDownload,
              icon: _isDownloading 
                ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
                : const Icon(Icons.download),
              label: Text(_isDownloading ? 'Downloading...' : 'Download'),
            ),
          ),
          if (_logs.isNotEmpty && _isDownloading) ...[
            const SizedBox(height: 10),
            Text(_logs.last, style: const TextStyle(fontSize: 12, color: Colors.grey)),
          ],
          const Divider(),
          const Align(
            alignment: Alignment.centerLeft,
            child: Text("Received Files", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
          ),
          const SizedBox(height: 8),
          Expanded(
            child: _receivedFiles.isEmpty 
              ? const Center(child: Text("No files received yet", style: TextStyle(color: Colors.grey)))
              : ListView.builder(
                  itemCount: _receivedFiles.length,
                  itemBuilder: (ctx, i) {
                    final file = _receivedFiles[i];
                    return Card(
                      child: ListTile(
                        leading: const Icon(Icons.insert_drive_file),
                        title: Text(file.name, maxLines: 1, overflow: TextOverflow.ellipsis),
                        subtitle: Text("${file.time.hour}:${file.time.minute}"),
                        trailing: IconButton(
                          icon: const Icon(Icons.share),
                          onPressed: () => Share.shareXFiles([XFile(file.path)]),
                          tooltip: 'Share / Export',
                        ),
                      ),
                    );
                  },
                ),
          ),
        ],
      ),
    );
  }

  Future<void> _scanQRCode() async {
    // Request camera permission
    var status = await Permission.camera.request();
    if (status.isGranted) {
      if (!mounted) return;
      final String? code = await Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const QRScannerScreen()),
      );

      if (code != null) {
        setState(() {
          _controller.text = code;
        });
      }
    } else {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Camera permission is required to scan QR code')),
      );
    }
  }
}

class QRScannerScreen extends StatefulWidget {
  const QRScannerScreen({super.key});

  @override
  State<QRScannerScreen> createState() => _QRScannerScreenState();
}

class _QRScannerScreenState extends State<QRScannerScreen> {
  bool _hasScanned = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Scan Ticket QR Code')),
      body: MobileScanner(
        onDetect: (capture) {
          if (_hasScanned) return; // Guard against multiple pops
          
          final List<Barcode> barcodes = capture.barcodes;
          for (final barcode in barcodes) {
            if (barcode.rawValue != null) {
              _hasScanned = true;
              Navigator.pop(context, barcode.rawValue);
              break;
            }
          }
        },
      ),
    );
  }
}
